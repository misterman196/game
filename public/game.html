<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ball Battle Arena</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #111;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        
        .game-header {
            width: 100%;
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
        }
        
        .room-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .room-code {
            background: #4CAF50;
            padding: 8px 15px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 18px;
            letter-spacing: 2px;
        }
        
        .player-info {
            display: flex;
            gap: 30px;
        }
        
        .player-stats {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .player-name {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        
        .health-bar {
            width: 150px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        
        .health-fill {
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s;
        }
        
        #player1Health {
            background: linear-gradient(to right, #4CAF50, #8BC34A);
        }
        
        #player2Health {
            background: linear-gradient(to right, #2196F3, #03A9F4);
        }
        
        .health-text {
            position: absolute;
            width: 100%;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            line-height: 20px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .game-container {
            position: relative;
            margin: 20px 0;
        }
        
        #gameCanvas {
            background-color: #1a1a1a;
            display: block;
            border: 3px solid #333;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .controls-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 250px;
        }
        
        .controls-info h3 {
            margin-bottom: 10px;
            color: #4CAF50;
        }
        
        .controls-info p {
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .key {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
            min-width: 20px;
            text-align: center;
        }
        
        .waiting-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        
        .waiting-screen h2 {
            margin-bottom: 20px;
            color: #4CAF50;
            font-size: 24px;
        }
        
        .room-code-share {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .countdown {
            font-size: 72px;
            font-weight: bold;
            color: #FF5722;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            display: none;
        }
        
        .game-over h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #FF5722;
        }
        
        .winner-message {
            font-size: 24px;
            margin-bottom: 30px;
            color: #4CAF50;
        }
        
        .restart-btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .restart-btn:hover {
            background: #1976D2;
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <div class="game-header">
        <div class="room-info">
            <div class="room-code" id="roomCodeDisplay">ROOM: ABCD</div>
            <div class="player-info">
                <div class="player-stats">
                    <div class="player-name" id="player1Name">Player 1</div>
                    <div class="health-bar">
                        <div class="health-fill" id="player1Health" style="width: 100%"></div>
                        <div class="health-text" id="player1HealthText">100/100</div>
                    </div>
                </div>
                <div class="player-stats">
                    <div class="player-name" id="player2Name">Player 2</div>
                    <div class="health-bar">
                        <div class="health-fill" id="player2Health" style="width: 100%"></div>
                        <div class="health-text" id="player2HealthText">100/100</div>
                    </div>
                </div>
            </div>
        </div>
        <div>Ball Battle Arena</div>
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="1000" height="600"></canvas>
        
        <div class="controls-info">
            <h3>Controls:</h3>
            <p><span class="key">MOUSE</span> Aim crosshair & position shield</p>
            <p><span class="key">HOLD LMB</span> Swing sword</p>
            <p><span class="key">RELEASE LMB</span> Use shield</p>
            <p><span class="key">R</span> Reset position (when dead)</p>
        </div>
        
        <div class="waiting-screen" id="waitingScreen">
            <h2>Waiting for opponent...</h2>
            <div class="room-code-share">
                Room Code: <span id="shareRoomCode">ABCD</span><br>
                Share this code with your opponent!
            </div>
        </div>
        
        <div class="game-over" id="gameOverScreen">
            <h1>GAME OVER</h1>
            <div class="winner-message" id="winnerMessage">Player wins!</div>
            <button class="restart-btn" onclick="window.location.reload()">Play Again</button>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const roomCode = urlParams.get('room');
        const playerName = decodeURIComponent(urlParams.get('player'));
        const playerId = urlParams.get('playerId');
        
        // Initialize Socket.io
        const socket = io();
        
        // DOM Elements
        const waitingScreen = document.getElementById('waitingScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const winnerMessage = document.getElementById('winnerMessage');
        const roomCodeDisplay = document.getElementById('roomCodeDisplay');
        const shareRoomCode = document.getElementById('shareRoomCode');
        
        // Set room code display
        roomCodeDisplay.textContent = `ROOM: ${roomCode}`;
        shareRoomCode.textContent = roomCode;
        
        // Game state
        let gameState = {
            players: {},
            playerId: playerId,
            roomCode: roomCode,
            gameStarted: false,
            gameOver: false,
            countdown: 3
        };
        
        // Join the game room
        socket.emit('joinGame', {
            roomCode: roomCode,
            playerId: playerId,
            playerName: playerName
        });
        
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game constants
        const BOX = {
            x: 50,
            y: 50,
            width: canvas.width - 100,
            height: canvas.height - 100
        };
        
        const MAX_HEALTH = 100;
        
        // Player class
        class Player {
            constructor(id, name, isLocal = false) {
                this.id = id;
                this.name = name;
                this.isLocal = isLocal;
                
                // Position and physics
                this.x = isLocal ? canvas.width * 0.25 : canvas.width * 0.75;
                this.y = canvas.height / 2;
                this.radius = 20;
                this.velocityX = 0;
                this.velocityY = 0;
                this.color = isLocal ? '#4CAF50' : '#2196F3';
                
                // Health
                this.health = MAX_HEALTH;
                this.maxHealth = MAX_HEALTH;
                this.isDead = false;
                
                // Shield
                this.shield = {
                    width: 30,
                    height: 70,
                    distance: 40,
                    active: true,
                    angle: 0
                };
                
                // Sword
                this.sword = {
                    width: 60,
                    height: 10,
                    distance: 50,
                    active: false,
                    isSwinging: false,
                    swingAngle: 0,
                    swingDirection: 1,
                    swingCooldown: 0,
                    currentSwingSide: 'right'
                };
                
                // Sword hitbox
                this.swordHitbox = {
                    width: 100,
                    height: 60,
                    visible: false,
                    fixedX: 0,
                    fixedY: 0,
                    fixedAngle: 0,
                    swingSide: 'right'
                };
            }
            
            update(deltaTime) {
                // Apply gravity
                this.velocityY += 0.4;
                
                // Update position
                this.x += this.velocityX;
                this.y += this.velocityY;
                
                // Apply friction
                this.velocityX *= 0.98;
                this.velocityY *= 0.98;
                
                // Check boundaries
                this.checkBoundaries();
                
                // Update sword cooldown
                if (this.sword.swingCooldown > 0) {
                    this.sword.swingCooldown -= deltaTime;
                }
                
                // Update sword animation
                if (this.sword.isSwinging) {
                    this.sword.swingAngle += 0.15 * this.sword.swingDirection;
                    
                    if (Math.abs(this.sword.swingAngle) >= Math.PI / 2) {
                        this.sword.isSwinging = false;
                        this.sword.swingCooldown = 500;
                        this.swordHitbox.visible = false;
                    }
                }
            }
            
            checkBoundaries() {
                // Left wall
                if (this.x - this.radius < BOX.x) {
                    this.x = BOX.x + this.radius;
                    this.velocityX = -this.velocityX * 0.8;
                }
                
                // Right wall
                if (this.x + this.radius > BOX.x + BOX.width) {
                    this.x = BOX.x + BOX.width - this.radius;
                    this.velocityX = -this.velocityX * 0.8;
                }
                
                // Top wall
                if (this.y - this.radius < BOX.y) {
                    this.y = BOX.y + this.radius;
                    this.velocityY = -this.velocityY * 0.8;
                }
                
                // Bottom wall
                if (this.y + this.radius > BOX.y + BOX.height) {
                    this.y = BOX.y + BOX.height - this.radius;
                    this.velocityY = -this.velocityY * 0.8;
                }
            }
            
            takeDamage(amount, attackerId) {
                this.health = Math.max(0, this.health - amount);
                if (this.health <= 0 && !this.isDead) {
                    this.isDead = true;
                    socket.emit('playerDied', {
                        roomCode: gameState.roomCode,
                        playerId: this.id,
                        killerId: attackerId
                    });
                }
                
                // Update health display
                this.updateHealthDisplay();
            }
            
            updateHealthDisplay() {
                const healthPercent = (this.health / this.maxHealth) * 100;
                const healthBar = this.isLocal ? 
                    document.getElementById('player1Health') : 
                    document.getElementById('player2Health');
                const healthText = this.isLocal ?
                    document.getElementById('player1HealthText') :
                    document.getElementById('player2HealthText');
                
                if (healthBar && healthText) {
                    healthBar.style.width = `${healthPercent}%`;
                    healthText.textContent = `${Math.round(this.health)}/${this.maxHealth}`;
                    
                    // Change color based on health
                    if (healthPercent < 30) {
                        healthBar.style.background = 'linear-gradient(to right, #FF5722, #FF9800)';
                    } else if (healthPercent < 60) {
                        healthBar.style.background = 'linear-gradient(to right, #FFC107, #FFEB3B)';
                    } else {
                        healthBar.style.background = this.isLocal ? 
                            'linear-gradient(to right, #4CAF50, #8BC34A)' :
                            'linear-gradient(to right, #2196F3, #03A9F4)';
                    }
                }
            }
            
            draw() {
                // Draw health above player
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${this.name} (${Math.round(this.health)} HP)`, this.x, this.y - this.radius - 10);
                ctx.restore();
                
                // Draw ball
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                
                const gradient = ctx.createRadialGradient(
                    this.x - 5, this.y - 5, 1,
                    this.x, this.y, this.radius
                );
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(0.5, this.color);
                gradient.addColorStop(1, this.isLocal ? '#2E7D32' : '#1565C0');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw shield or sword
                if (this.shield.active) {
                    this.drawShield();
                }
                
                if (this.swordHitbox.visible) {
                    this.drawSwordHitbox();
                }
                
                if (this.sword.active) {
                    this.drawSword();
                }
            }
            
            drawShield() {
                // Calculate shield position based on mouse
                let dx = 0, dy = -1;
                if (this.isLocal) {
                    dx = gameState.mouseX - this.x;
                    dy = gameState.mouseY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 0) {
                        dx /= distance;
                        dy /= distance;
                    }
                } else {
                    // For remote player, use stored angle
                    const angle = this.shield.angle;
                    dx = Math.cos(angle);
                    dy = Math.sin(angle);
                }
                
                const shieldX = this.x + dx * this.shield.distance;
                const shieldY = this.y + dy * this.shield.distance;
                const angle = Math.atan2(dy, dx);
                
                ctx.save();
                ctx.translate(shieldX, shieldY);
                ctx.rotate(angle);
                
                // Draw shield
                ctx.fillStyle = 'rgba(52, 152, 219, 0.6)';
                ctx.fillRect(-this.shield.width/2, -this.shield.height/2, 
                           this.shield.width, this.shield.height);
                ctx.strokeStyle = '#2980b9';
                ctx.lineWidth = 2;
                ctx.strokeRect(-this.shield.width/2, -this.shield.height/2, 
                             this.shield.width, this.shield.height);
                
                // Draw shield detail
                ctx.beginPath();
                ctx.moveTo(0, -this.shield.height/2);
                ctx.lineTo(0, this.shield.height/2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.restore();
            }
            
            drawSword() {
                // Calculate sword position
                let dx = 0, dy = -1;
                if (this.isLocal) {
                    dx = gameState.mouseX - this.x;
                    dy = gameState.mouseY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > 0) {
                        dx /= distance;
                        dy /= distance;
                    }
                } else {
                    // For remote player, use stored angle
                    const angle = this.sword.swingAngle;
                    dx = Math.cos(angle);
                    dy = Math.sin(angle);
                }
                
                // Apply swing rotation if swinging
                if (this.sword.isSwinging) {
                    const swingCos = Math.cos(this.sword.swingAngle);
                    const swingSin = Math.sin(this.sword.swingAngle);
                    const tempDx = dx * swingCos - dy * swingSin;
                    const tempDy = dx * swingSin + dy * swingCos;
                    dx = tempDx;
                    dy = tempDy;
                }
                
                const swordX = this.x + dx * this.sword.distance;
                const swordY = this.y + dy * this.sword.distance;
                const angle = Math.atan2(dy, dx);
                
                ctx.save();
                ctx.translate(swordX, swordY);
                ctx.rotate(angle);
                
                // Draw sword
                const swordGradient = ctx.createLinearGradient(
                    0, -this.sword.height/2,
                    this.sword.width, -this.sword.height/2
                );
                swordGradient.addColorStop(0, 'rgba(231, 76, 60, 0.9)');
                swordGradient.addColorStop(1, 'rgba(255, 255, 255, 0.8)');
                
                ctx.fillStyle = swordGradient;
                ctx.beginPath();
                ctx.moveTo(0, -this.sword.height/2);
                ctx.lineTo(this.sword.width, -this.sword.height/4);
                ctx.lineTo(this.sword.width, this.sword.height/4);
                ctx.lineTo(0, this.sword.height/2);
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#c0392b';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.restore();
            }
            
            drawSwordHitbox() {
                if (!this.swordHitbox.visible) return;
                
                ctx.save();
                ctx.translate(this.swordHitbox.fixedX, this.swordHitbox.fixedY);
                ctx.rotate(this.swordHitbox.fixedAngle);
                
                // Draw hitbox
                ctx.fillStyle = 'rgba(231, 76, 60, 0.3)';
                ctx.fillRect(-this.swordHitbox.width/2, -this.swordHitbox.height/2,
                           this.swordHitbox.width, this.swordHitbox.height);
                ctx.strokeStyle = 'rgba(231, 76, 60, 0.7)';
                ctx.lineWidth = 2;
                ctx.strokeRect(-this.swordHitbox.width/2, -this.swordHitbox.height/2,
                             this.swordHitbox.width, this.swordHitbox.height);
                
                ctx.restore();
            }
        }
        
        // Event listeners for local player
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;
        let mouseDown = false;
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
            gameState.mouseX = mouseX;
            gameState.mouseY = mouseY;
            
            // Send mouse position to server
            if (gameState.gameStarted && !gameState.gameOver) {
                socket.emit('playerUpdate', {
                    roomCode: roomCode,
                    playerId: playerId,
                    mouseX: mouseX,
                    mouseY: mouseY
                });
            }
        });
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Left click
                mouseDown = true;
                
                if (gameState.gameStarted && !gameState.gameOver) {
                    const localPlayer = gameState.players[playerId];
                    if (localPlayer && !localPlayer.sword.isSwinging && localPlayer.sword.swingCooldown <= 0) {
                        // Start sword swing
                        localPlayer.sword.active = true;
                        localPlayer.shield.active = false;
                        localPlayer.sword.isSwinging = true;
                        localPlayer.sword.swingAngle = 0;
                        localPlayer.swordHitbox.visible = true;
                        
                        // Set fixed hitbox position
                        const dx = mouseX - localPlayer.x;
                        const dy = mouseY - localPlayer.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        let hitboxDx = 0, hitboxDy = -1;
                        
                        if (distance > 0) {
                            hitboxDx = dx / distance;
                            hitboxDy = dy / distance;
                        }
                        
                        // Apply swing side rotation
                        const swingStartAngle = localPlayer.sword.currentSwingSide === 'right' ? 
                            -Math.PI / 4 : Math.PI / 4;
                        const swingCos = Math.cos(swingStartAngle);
                        const swingSin = Math.sin(swingStartAngle);
                        const finalDx = hitboxDx * swingCos - hitboxDy * swingSin;
                        const finalDy = hitboxDx * swingSin + hitboxDy * swingCos;
                        
                        localPlayer.swordHitbox.fixedX = localPlayer.x + finalDx * 80;
                        localPlayer.swordHitbox.fixedY = localPlayer.y + finalDy * 80;
                        localPlayer.swordHitbox.fixedAngle = Math.atan2(finalDy, finalDx);
                        localPlayer.swordHitbox.swingSide = localPlayer.sword.currentSwingSide;
                        
                        // Alternate swing side for next swing
                        localPlayer.sword.currentSwingSide = localPlayer.sword.currentSwingSide === 'right' ? 
                            'left' : 'right';
                        
                        // Send sword swing to server
                        socket.emit('swordSwing', {
                            roomCode: roomCode,
                            playerId: playerId,
                            hitbox: {
                                x: localPlayer.swordHitbox.fixedX,
                                y: localPlayer.swordHitbox.fixedY,
                                angle: localPlayer.swordHitbox.fixedAngle,
                                side: localPlayer.swordHitbox.swingSide
                            }
                        });
                    }
                }
            }
        });
        
        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                mouseDown = false;
                
                if (gameState.gameStarted && !gameState.gameOver) {
                    const localPlayer = gameState.players[playerId];
                    if (localPlayer) {
                        localPlayer.sword.active = false;
                        localPlayer.shield.active = true;
                        
                        socket.emit('swordRelease', {
                            roomCode: roomCode,
                            playerId: playerId
                        });
                    }
                }
            }
        });
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' || e.key === 'R') {
                if (gameState.gameStarted && !gameState.gameOver) {
                    const localPlayer = gameState.players[playerId];
                    if (localPlayer && localPlayer.isDead) {
                        // Reset player position
                        localPlayer.x = canvas.width * 0.25;
                        localPlayer.y = canvas.height / 2;
                        localPlayer.velocityX = 0;
                        localPlayer.velocityY = 0;
                        localPlayer.health = MAX_HEALTH;
                        localPlayer.isDead = false;
                        localPlayer.updateHealthDisplay();
                        
                        socket.emit('playerRespawn', {
                            roomCode: roomCode,
                            playerId: playerId
                        });
                    }
                }
            }
        });
        
        // Socket event handlers
        socket.on('gameState', (state) => {
            gameState.gameStarted = state.gameStarted;
            gameState.countdown = state.countdown;
            
            if (state.gameStarted && !waitingScreen.style.display) {
                waitingScreen.style.display = 'none';
            }
            
            // Update players
            for (const [id, playerData] of Object.entries(state.players)) {
                if (!gameState.players[id]) {
                    // Create new player
                    gameState.players[id] = new Player(
                        id,
                        playerData.name,
                        id === playerId
                    );
                    
                    // Update player names in UI
                    if (id === playerId) {
                        document.getElementById('player1Name').textContent = playerData.name;
                    } else {
                        document.getElementById('player2Name').textContent = playerData.name;
                    }
                }
                
                // Update existing player
                const player = gameState.players[id];
                if (id !== playerId) { // Don't overwrite local player's position
                    player.x = playerData.x;
                    player.y = playerData.y;
                    player.velocityX =
